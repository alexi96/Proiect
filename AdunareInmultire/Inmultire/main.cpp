#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma comment (lib, "msmpi.lib")

#include "Utilities.h"

#include "Debug.h"

int numberOfTasks;
int currentRank;
int hostNameLength;
char hostName[MPI_MAX_PROCESSOR_NAME];
bool usingMpi = false;

void GenerateMatrix(Byte** matrix, Number x, Number y, int rowStart, int length) {
	int num;
	for (int i = rowStart; i < rowStart + length; ++i) {
		num = y[i];
		Byte* row = matrix[i];
		for (unsigned int col = 0; col < x.Length(); ++col) {
			row[col] = x[col] * y[i];
		}
	}
}

int main(int argc, char** argv) {
	int rc = MPI_Init(&argc, &argv);
	usingMpi = rc == MPI_SUCCESS;
	if (usingMpi) {
		MPI_Comm_size(MPI_COMM_WORLD, &numberOfTasks);
		MPI_Comm_rank(MPI_COMM_WORLD, &currentRank);
		MPI_Get_processor_name(hostName, &hostNameLength);
	}

	if (argc == 0) {
		cout << 'E';
		cerr << "Need 2 arguments";
		return EXIT_FAILURE;
	}

	char* strX = argv[1];
	char* strY = argv[2];
	int strXLen = strlen(strX);
	int strYLen = strlen(strY);

	if (strXLen > strYLen) {
		char * t = strX;
		strX = strY;
		strY = t;
		int tl = strXLen;
		strXLen = strYLen;
		strYLen = tl;
	}

	Number x(strX);
	Number y(strY);

	DEBUG(x);
	DEBUG("\n");
	DEBUG(y);
	DEBUG("\n");	

	int xLen = x.Length();
	int yLen = y.Length();

	Byte** matrix = new Byte*[yLen];
	for (int i = 0; i < yLen; ++i) {
		matrix[i] = new Byte[xLen];
		for (int j = 0; j < xLen; ++j) {
			matrix[i][j] = 0;
		}
	}
	
	int length = y.Length() / numberOfTasks;

	if (length == 0) { // Daca numarul e prea mic
		if (currentRank == 0) { // il face rank 0 pe tot
			length = y.Length();
			numberOfTasks = 1;
		} else { // si altii se opresc
			MPI_Finalize();
			return EXIT_SUCCESS;
		}
	}

	int rowStart = currentRank * length;
	GenerateMatrix(matrix, x, y, rowStart, length); // Fac randuri in functie de rank

	DEBUG("Generated by rank ");
	DEBUG(currentRank);
	DEBUG("\n");
	DEBUG_MATRIX(matrix, yLen, xLen);

	if (!usingMpi || currentRank == 0) {
		// Pt fiecare rank
		int otherRankRowStart;
		for (int otherRank = 1; otherRank < numberOfTasks; ++otherRank) {
			// Primesc ce a facut (adica randuri de matrici)
			otherRankRowStart = otherRank * length;
			for (int row = otherRankRowStart; row < otherRankRowStart + length; ++row) {
				Byte* matrixRow = matrix[row];
				MPI_Recv(matrixRow, xLen, MPI_BYTE, otherRank, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
			}
		}

		DEBUG_MATRIX(matrix, yLen, xLen);
	} else if (usingMpi) {
		// Trimit catre rank 0 ce am facut eu
		for (int i = rowStart; i < rowStart + length; ++i) {
			Byte* row = matrix[i];
			MPI_Send(row, xLen, MPI_BYTE, 0, 0, MPI_COMM_WORLD);
		}

		MPI_Finalize();
		return EXIT_SUCCESS;
	}

	Byte* res = new Byte[xLen + yLen];
	for (int i = 0; i < xLen + yLen; ++i) {
		res[i] = 0;
	}
	int tr = 0;
	int t;
	int sum = 0;
	int index = 0;
	for (int col = 0; col < xLen + yLen; ++col) {
		for (int row = 0; row < yLen; ++row) {
			if (col - row < 0 || col - row >= xLen) {
				continue;
			}

			t = matrix[row][col - row];
			res[col] += t;
		}

		res[col] += tr;
		tr = res[col] / 10;
		res[col] %= 10;
	}

	for (int i = 0; i < yLen; ++i) {
		delete matrix[i];
		matrix[i] = nullptr;
	}
	delete matrix;
	matrix = nullptr;

	PrintAsNumber(res, xLen + yLen);

	delete res;
	res = nullptr;

	MPI_Finalize();

	return EXIT_SUCCESS;
}
